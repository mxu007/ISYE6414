getwd()
data <- read.table("transcoding_measurement.tsv", sep='\t', header=TRUE)
data <- data[,-1]
data <- data[ ,-which(names(data) == "frames")]
data <- data[ ,-which(names(data) == "size")]
data <- data[ ,-which(names(data) == "b_size")]
data_num <- data[,sapply(data,is.numeric)]
round(cor(data_num),2)
library(corrplot)
par(mfrow=c(1,1))
X = model.matrix(lm(utime ~ ., data = data))[,-1]
X = cbind(data$utime, X)
corrplot(cor(X), tl.cex = 1)
model <- lm(log(utime)~.,data=data)
summary(model)
cookdist <- cooks.distance(model)
plot(cookdist, main = "Cook's Distance")
detach(data)
HighCDP <- which(cookdist >= 0.05)
data[HighCDP,]
newdata<-data[-HighCDP,]
newdata_ind <- sample(1:nrow(newdata), floor(0.9*nrow(newdata)))
newdata_ind
length(newdata_ind)
nrow(newdata)
newdata<- newdata[newdata_ind,]
newdata_final_test <- newdata[-newdata_ind,]
nrow(newdata)
nrow(newdata_final_test)
nrow(newdata_final_test)+nrow(newdata)
nrow(data)
newdata<-data[-HighCDP,]
set.seed(999)
newdata_ind <- sample(1:nrow(newdata), floor(0.9*nrow(newdata)))
newdata<- newdata[newdata_ind,]
newdata_final_test <- newdata[-newdata_ind,]
nrow(newdata_final_test)
nrow(newdata)
nrow(newdata)+nrow(newdata_final_test)
nrow(data)
newdata<-data[-HighCDP,]
nrow(newdata)
newdata<-data[-HighCDP,]
newdata_ind <- sample(1:nrow(newdata), floor(0.9*nrow(newdata)))
length(newdata_ind)
head(newdata_ind)
nrow(newdata)
newdata<- newdata[newdata_ind,]
nrow(newdata)
61903+6166
newdata<-data[-HighCDP,]
set.seed(999)
newdata_ind <- sample(1:nrow(data[-HighCDP,]), floor(0.9*nrow(data[-HighCDP,])))
newdata<- (data[-HighCDP,])[newdata_ind,]
newdata_final_test <- (data[-HighCDP,])[-newdata_ind,]
dim(newdata)
dim(newdata_final_test)
nrow(newdata_final_test) + nrow(newdata)
nrow(data[-HighCDP,])
head(newdata)
head(newdata_final_test)
model_woHighCDP <- lm(log(utime)~.,data=newdata)
summary(model_woHighCDP)
attach(newdata)
res = model_woHighCDP$res
par(mfrow = c(4,4))
#Verifying Constant variance and Linearity
plot(utime, res, xlab = "utime", ylab = "Residuals", pch = 19, main = 'Residual vs utime')
abline(h = 0,col="red")
plot(height, res, xlab = "height", ylab = "Residuals", pch = 19, main = 'Residual vs height')
abline(h = 0,col="red")
plot(bitrate, res, xlab = "bitrate", ylab = "Residuals", pch = 19, main = 'Residual vs bitrate')
abline(h = 0,col="red")
plot(framerate, res, xlab = "framerate", ylab = "Residuals", pch = 19, main = 'Residual vs framerate')
abline(h = 0,col="red")
plot(i, res, xlab = "i", ylab = "Residuals", pch = 19, main = 'Residual vs i')
abline(h = 0,col="red")
plot(p, res, xlab = "p", ylab = "Residuals", pch = 19, main = 'Residual vs p')
abline(h = 0,col="red")
plot(b, res, xlab = "b", ylab = "Residuals", pch = 19, main = 'Residual vs b')
abline(h = 0,col="red")
plot(i_size, res, xlab = "i_size", ylab = "Residuals", pch = 19, main = 'Residual vs i_size')
abline(h = 0,col="red")
plot(p_size, res, xlab = "p_size", ylab = "Residuals", pch = 19, main = 'Residual vs p_size')
abline(h = 0,col="red")
plot(o_height, res, xlab = "o_height", ylab = "Residuals", pch = 19, main = 'Residual vs o_height')
abline(h = 0,col="red")
plot(o_bitrate, res, xlab = "o_bitrate", ylab = "Residuals", pch = 19, main = 'Residual vs o_bitrate')
abline(h = 0,col="red")
plot(o_framerate, res, xlab = "o_framerate", ylab = "Residuals", pch = 19, main = 'Residual vs o_framerate')
abline(h = 0,col="red")
plot(umem, res, xlab = "umem", ylab = "Residuals", pch = 19, main = 'Residual vs umem')
abline(h = 0,col="red")
#Verifying Normality of residuals
hist(res, xlab="Residuals", main= "Histogram of Residuals")
qqPlot(residuals(model_woHighCDP),lwd=1, main = 'Normality of residuals')
#Verifying Independence of residuals
plot(res, xlab = 'Sequence',ylab = 'Residuals', main = 'Residuals Independence')
#Identifying influencing datapoints
cookdist <- cooks.distance(model_woHighCDP)
plot(cookdist, main = "Cook's Distance")
library(MASS)
library(car)
#Reading the data from file
data <- read.table("transcoding_measurement.tsv", sep='\t', header=TRUE)
# Remove first column
data <- data[,-1]
#Removing the frames column as i + p + b = frame
data <- data[ ,-which(names(data) == "frames")]
#Removing the size column as i_size + b_size + p_size = size
data <- data[ ,-which(names(data) == "size")]
#Removing the b_size column as its empty
data <- data[ ,-which(names(data) == "b_size")]
# Subset data by either factor or numeric
data_num <- data[,sapply(data,is.numeric)]
# Understanding correlations between variables
round(cor(data_num),2)
# Correlation Matrix
library(corrplot)
par(mfrow=c(1,1))
X = model.matrix(lm(utime ~ ., data = data))[,-1]
X = cbind(data$utime, X)
corrplot(cor(X), tl.cex = 1)
#Strong correlation seen in height and width variables
plot(data$height,data$width)
plot(data$o_height,data$o_width)
#Removing the width column as its highly correlated with height
data <- data[ ,-which(names(data) == "width")]
#Removing the width column as its highly correlated with height
data <- data[ ,-which(names(data) == "o_width")]
# Subset data by either factor or numeric
data_fac <- data[,sapply(data,is.factor)]
data_num <- data[,sapply(data,is.numeric)]
colnames(data_fac)
colnames(data_num)
# Frequency/Histogram Plot
par(mfrow=c(4,4))
for (col in colnames(data_fac)) {
plot(data_fac[,col], xlab=col, ylab="Frequency/Count", main=paste("Frequency of" , col)  )
}
for ( col in colnames(data_num)) {
hist(data[,col], xlab=col, ylab="Frequency/Count", main=paste("Histogram of" , col))
}
data_res <- data_num[,14]
data_num <- data_num[,-14]
# Scatter/box Plot for numeric variables
par(mfrow=c(4,4))
for (col in colnames(data_fac)) {
boxplot(data_res~data_fac[,col], xlab=col, ylab="Transcoding Time in sec")
}
for (col in colnames(data_num)) {
plot(data_res~data_num[,col], xlab=col, ylab="Transcoding Time in sec")
}
nrows(newdata_final_test)
nrow(newdata_final_test)
head(newdata_final_test)
dim(newdata_final_test)
X_test_final <- newdata_final_test[,-18]
y_test_final <- newdata_final_test[,18]
full_model_final <- lm(log(utime)~.,data=newdata)
y_predict_full_final <- predict(full_model_final, X_test_final)
y_predict_full_final <- exp(y_predict_full_final)
mse_full_final <- mean((y_predict_full-y_test_final)^2))
mse_full_final <- mean((y_predict_full-y_test_final)^2)
mse_full_final <- mean((y_predict_full_final-y_test_final)^2)
mse_full_final
X_train_final <- model.matrix(full_model_final)[,-1]
dim(X_train_final)
dim(newdata)
X_test_final <- (model.matrix(log(utime)~.,data=newdata_final_test))[,-1]
dim(X_test_final)
dim(newdata_final_test)
head(X_test_final)
head(newdata_final_test)
y_test_final
head(y_test_final)
head(newdata_final_test)
X_train_final <- model.matrix(full_model_final)[,-1]
X_test_final <- (model.matrix(log(utime)~.,data=newdata_final_test))[,-1]
y_train_final <- log(newdata[,c('utime')])
elastic_model_cv_final <- cv.glmnet(X_train_final, y_train_final, alpha = 0.5, nfolds=10)
elastic_model_final <- glmnet(X_train_final, y_train_final, alpha = elastic_model_cv_final$lambda.min)
library(glmnet)
elastic_model_cv <- cv.glmnet(X_train, y_train, alpha = 0.5, nfolds=10)
elastic_model_cv_final <- cv.glmnet(X_train_final, y_train_final, alpha = 0.5, nfolds=10)
elastic_model_final <- glmnet(X_train_final, y_train_final, alpha = elastic_model_cv_final$lambda.min)
y_predict_elastic_final <- predict(elastic_model_final, newx = X_test, s= elastic_model_cv_final$lambda.min, type="response")
y_predict_elastic_final <- exp(y_predict_elastic_final)
y_predict_elastic_final <- predict(elastic_model_final, newx = X_test, s= elastic_model_cv_final$lambda.min, type="response")
elastic_model_cv_final <- cv.glmnet(X_train_final, y_train_final, alpha = 0.5, nfolds=10)
elastic_model_final <- glmnet(X_train_final, y_train_final, alpha = elastic_model_cv_final$lambda.min)
y_predict_elastic_final <- predict(elastic_model_final, newx = X_test_final, s= elastic_model_cv_final$lambda.min, type="response")
y_predict_elastic_final <- exp(y_predict_elastic_final)
mse_elastic_final <- mean((y_predict_elastic_final-y_test_final)^2))
mse_elastic_final <- mean((y_predict_elastic_final-y_test_final)^2)
mse_elastic_final
mse_full_final
